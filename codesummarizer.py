# -*- coding: utf-8 -*-
"""day1calculator.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N11e7zxtLYX7lnMYqlmy6CEVDE5s8yoz
"""



class Calculator:
    def add(self, x, y):
        return x + y

    def subtract(self, x, y):
        return x - y

    def multiply(self, x, y):
        return x * y

    def divide(self, x, y):
        if y != 0:
            return x / y
        else:
            return "Division by zero is not allowed"


def main():
    calculator = Calculator()
    while True:
        print("Options:")
        print("Enter 'add' for addition")
        print("Enter 'subtract' for subtraction")
        print("Enter 'multiply' for multiplication")
        print("Enter 'divide' for division")
        print("Enter 'quit' to end the program")
        user_input = input(": ")

        if user_input == "quit":
            break
        elif user_input in ["add", "subtract", "multiply", "divide"]:
            try:
                num1 = float(input("Enter first number: "))
                num2 = float(input("Enter second number: "))
                if user_input == "add":
                    result = calculator.add(num1, num2)
                elif user_input == "subtract":
                    result = calculator.subtract(num1, num2)
                elif user_input == "multiply":
                    result = calculator.multiply(num1, num2)
                elif user_input == "divide":
                    result = calculator.divide(num1, num2)
                print("Result:", result)
            except ValueError:
                print("Invalid input. Please enter a valid number.")
        else:
            print("Invalid input. Please enter a valid option.")


if __name__ == "__main__":
    main()

class Calculator:
    def evaluate_expression(self, expression):
        try:
            result = eval(expression)
            return result
        except (SyntaxError, NameError, ZeroDivisionError) as e:
            return f"Error: {e}"
        except Exception as e:
            return f"An error occurred: {e}"


def main():
    calculator = Calculator()
    while True:
        try:
            expression = input("Enter a mathematical expression: ")
            if expression.lower() == 'quit':
                print("Exiting the calculator...")
                break
            result = calculator.evaluate_expression(expression)
            print("Result:", result)
        except KeyboardInterrupt:
            print("\nExiting the calculator...")
            break


if __name__ == "__main__":
    main()

from gensim.summarization import summarize

def summarize_text(text, ratio=0.2):
    """
    Summarize a given text using the gensim library.

    Args:
    - text (str): The input text to be summarized.
    - ratio (float): The ratio of sentences in the original text to be retained in the summary (default is 0.2).

    Returns:
    - summary (str): The summarized text.
    """
    summary = summarize(text, ratio=ratio)
    return summary

# Example usage
large_text = """
Your large text goes here...
"""

summary = summarize_text(large_text)
print(summary)

from gensim.summarization import summarize

def summarize_text(text, ratio=0.2):
    """
    Summarize a given text using the gensim library.

    Args:
    - text (str): The input text to be summarized.
    - ratio (float): The ratio of sentences in the original text to be retained in the summary (default is 0.2).

    Returns:
    - summary (str): The summarized text.
    """
    summary = summarize(text, ratio=ratio)
    return summary

# Example usage
large_text = """
Your large text goes here... Abstractive text summarization generates legible sentences from the entirety of the text provided. It rewrites large amounts of text by creating acceptable representations, which is further processed and summarized by natural language processing.
What makes this method unique is its almost AI-like ability to use a machineâ€™s semantic capability to process text and iron out the kinks using NLP.
Although it might not be as simple to use compared to the extractive method, in many situations, abstract summarization is far more useful. In a lot of ways, it is a precursor to full-fledged AI writing tools. However, this does not mean that there is no need for extractive summarization.
"""

summary = summarize_text(large_text)
print(summary)



!pip install gensim